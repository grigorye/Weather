//
//  CoreDataCityQuerying.swift
//  OpenWeatherMapKit/CityQueryingImp/CoreData
//
//  Created by Grigory Entin on 07/05/2018.
//  Copyright Â© 2018 Grigory Entin. All rights reserved.
//

import RxSwift
import CoreData
import Then

extension CityQueryingImp_CoreData$ {
    
    class CoreDataCityQuerying : CityQuerying {
        
        init() {()}
        deinit {()}
        
        let persistentContainer: NSPersistentContainer = BundledPersistentContainer(name: "CityInfos").then {
            $0.persistentStoreDescriptions[0].do {
                $0.isReadOnly = true
                $0.shouldMigrateStoreAutomatically = false
            }
            $0.loadPersistentStores { (_, error) in
                assert(nil == error)
            }
            let fetchRequest: NSFetchRequest<PersistentCityInfo> = PersistentCityInfo.fetchRequest()
            _ = try! $0.viewContext.count(for: fetchRequest)
        }
        
        func queryCity(matching text: String, completion: @escaping (CityQueryResult) -> Void) -> DisposableQuery {
            let observable = Observable<[CityInfo]>.create({ [persistentContainer] observer in
                var cancel: (() -> Void)?
                let progress = Progress(totalUnitCount: 101)
                progress.becomeCurrent(withPendingUnitCount: 1)
                persistentContainer.performBackgroundTask { (moc) in
                    progress.becomeCurrent(withPendingUnitCount: 100)
                    
                    let fetchRequest: NSFetchRequest<PersistentCityInfo> = PersistentCityInfo.fetchRequest().then {
                        $0.predicate = NSPredicate(format: "%K contains[cd] %@", #keyPath(PersistentCityInfo.name), text)
                    }
                    
                    let asyncFetchRequest = NSAsynchronousFetchRequest(fetchRequest: fetchRequest, completionBlock: { (result) in
                        let persistentCityInfos = result.finalResult!
                        _ = (text)
                        _ = (persistentCityInfos.count)
                        let cityInfos = persistentCityInfos.map { CityInfo.init(from: $0) }
                        #if false
                        Thread.sleep(forTimeInterval: 600)
                        #endif
                        observer.on(.next(cityInfos))
                        observer.on(.completed)
                    })
                    let result = try! moc.execute(asyncFetchRequest) as! NSAsynchronousFetchResult<PersistentCityInfo>
                    cancel = { result.cancel() }
                    
                    progress.resignCurrent()
                }
                progress.resignCurrent()
                return Disposables.create {
                    cancel?()
                    _ = text
                    progress.cancel()
                }
            })
            
            let disposeBag = DisposeBag()
            observable
                .observeOn(MainScheduler.asyncInstance)
                .subscribe(onNext: {
                    completion(.success($0))
                })
                .disposed(by: disposeBag)
            return disposeBag
        }
    }
}

extension CityQueryingImp_CoreData$$ /* *** AUTOGENERATED *** */ {
    typealias CoreDataCityQuerying = CityQueryingImp_CoreData$.CoreDataCityQuerying
}
